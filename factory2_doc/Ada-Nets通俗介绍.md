## [Ada-NETS: Face Clustering via Adaptive Neighbour Discovery in the Structure Space](https://github.com/damo-cv/Ada-NETS)

### 概述

这篇论文提出了一种名为Ada-NETS的算法，用于解决基于图卷积网络（GCN）进行人脸聚类时噪声边的问题。论文的主要贡献如下：

1. **背景和问题**：当前的GCN方法通常根据特征空间中的k近邻关系构建人脸图，容易引入大量噪声边，这些噪声边会连接不同类别的人脸，影响GCN的性能。
2. **结构空间转换**：Ada-NETS首先将每张人脸图像转换到一个新的结构空间中，在考虑邻居图像的特征后获得鲁棒的特征。这种转换使得相似性度量更准确，减少噪声边的引入。
3. **自适应邻居发现**：提出了一种自适应邻居发现策略，确定每张人脸图像应连接的适当边数，显著减少噪声边，同时保持有用的边，从而构建一个干净且丰富的图用于GCN聚类。
4. **实验结果**：在多个公共聚类数据集上的实验表明，Ada-NETS显著优于当前的最先进方法，证明了其优越性和泛化能力。
5. **技术细节**：
   - **结构空间**：通过考虑数据分布和纹理信息，将特征转换到结构空间，使用近邻关系增强特征。
   - **自适应滤波器**：通过学习特征模式，自适应地发现每个顶点的邻居，构建一个干净且丰富的图。
   - **GCN聚类**：利用构建的图进行GCN训练和聚类，通过边分类和特征聚合提高聚类性能。
6. **性能评价**：论文使用MS-Celeb-1M、DeepFashion和MSMT17三个数据集进行测试，结果表明Ada-NETS在各种聚类任务中均表现出色，尤其在消除噪声边和提高聚类准确性方面效果显著。

论文详细描述了其方法的理论基础、技术实现以及实验结果，证明了Ada-NETS在大规模人脸聚类任务中的有效性。

![image-20240704112559914](C:\Users\DG2024\AppData\Roaming\Typora\typora-user-images\image-20240704112559914.png)

### 自适应邻居发现策略

论文中的自适应邻居发现策略（Adaptive Neighbour Discovery）是Ada-NETS算法的关键部分，旨在解决传统k近邻方法中因连接数量固定而导致的噪声边问题。以下是详细解释：

#### 自适应邻居发现的动机

在传统的k近邻方法中，每个节点的邻居数量是固定的，这会引入很多噪声边。这些噪声边是指连接不同类别的节点，会导致信息传递过程中引入错误信息，降低图卷积网络（GCN）的聚类性能。

#### 自适应邻居发现的步骤

1. **结构空间**：

   - 首先，将特征转换到一个新的结构空间。在这个空间中，通过编码更多的纹理信息，使得特征更加鲁棒。

   - 使用变换函数 $\phi $将特征 $v_i$ 转换到结构空间，得到 $v_i^s$​：
     $$
     v_i^s = \phi(v_i \mid V)
     $$
     
   - 结构空间中的相似度度量通过结合余弦相似度和Jaccard相似度来计算：
     $$
     \kappa(v_i, v_j) = (1 - \eta) s_{\text{Jac}}(v_i, v_j) + \eta s_{\text{cos}}(v_i, v_j)
     $$
      其中，$\eta$ 是权重，${\text{Jac}} $和 $s_{\text{cos}}$ 分别是Jaccard相似度和余弦相似度。
   
2. **候选邻居质量准则**：

   - 为了评估候选邻居的质量，定义了一个启发式准则$Q(j)$，基于$F_β$分数： 
     $$
     Q(j) = F_j^\beta = \frac{(1 + \beta^2) \text{Pr}_j \text{Rc}_j}{\beta^2 \text{Pr}_j + \text{Rc}_j}
     $$
      其中，$\text{Pr}_j$ 和$ \text{Rc}_j$ 分别是前 $j$ 个候选邻居的精度和召回率，$\beta$ 是权衡精度和召回率的权重。

3. **自适应滤波器**：

   - 使用自适应滤波器来估计每个节点的最佳邻居数量 $k_{\text{off}}$。自适应滤波器通过寻找 $Q(j)$ 曲线的最大值位置来确定最佳邻居数量： 
     $$
     k_{\text{off}} = \arg\max_{j \in \{1, 2, \ldots, k\}} Q(j)
     $$
     
   - 自适应滤波器的输入是特征向量$[v_i, v_{i1}, v_{i2}, \ldots, v_{ik}]^T \in \mathbb{R}^{(k+1) \times D}$。训练过程中，使用Huber损失进行训练，模型为Bi-LSTM： 
     $$
     L_{\text{Huber}}=\frac{1}{B}\sum_{b=1}^{b}{L_{bHuber}^{b}}
     $$
     其中，$L_{\text{Huber}}^b$ 是第$b$个批次的Huber损失，$\xi = \frac{|k_{\text{off}}^b - \hat{k}_{\text{off}}^b|}{k_{\text{off}}^b}$。
   
4. **构建最终的图结构**：

   - 根据自适应滤波器的输出，构建最终的图结构：
     $$
     N^s(v_i, k) = \{v_{ij} \mid v_{ij} \in N(v_i, k), \text{Ind}_j \leq \hat{k}_{\text{off}}\}
     $$
      其中，$\text{Ind}_j$ 是 $v_{ij}$ 在结构空间中按相似度排序后的索引。

#### 自适应邻居发现的主要贡献

1. **解决噪声边问题**：
   - 通过自适应地确定每个节点的邻居数量，显著减少噪声边，提高图结构的质量。
2. **增强特征表示**：
   - 在结构空间中，特征表示更加鲁棒，使得GCN在进行特征聚合时能够得到更好的特征。
3. **提升聚类性能**：
   - 自适应邻居发现策略显著提升了GCN的聚类性能，使得Ada-NETS在多个公共数据集上都达到了最先进的性能。

### GCN模型训练

**输入图结构和特征**：将构建的图结构（邻接矩阵 $A$）和节点特征矩阵 $F$ 输入到GCN中。

**GCN层操作**：通过GCN层的操作，逐层更新节点特征：
$$
F^{l+1} = \sigma(D^{-\frac{1}{2}} A D^{-\frac{1}{2}} F^l W^l)
$$

​		其中，$A$ 是邻接矩阵，$D$ 是度矩阵，$F^l$ 是第 $l$ 层的输入特征矩阵，$W^l$ 是权重矩阵，$\sigma(\cdot)$是激活函数。

**损失函数**：

- **正样本损失**

$$
L_{\text{pos}} = \frac{1}{\| l_i = l_j \|} \sum_{l_i = l_j} [\beta_1 - y_{v_i,v_j}]_+
$$

  - **负样本损失**：

$$
L_{\text{neg}} = \max_{l_i \ne l_j} [\beta_2 + y_{v_i,v_j}]_+
$$


  - **整体损失**：
$$
  L_{\text{Hinge}} = L_{\text{neg}} + \lambda L_{\text{pos}}
$$


### 聚类结果提取

- **推理阶段**：将整个测试数据集输入GCN，得到增强的节点特征矩阵 $F^′$。根据特征相似度阈值 $\theta$，判断节点对之间是否存在连接，动态更新图结构。
- **并查集（Union-Find）**：使用并查集算法对连接的节点进行合并，形成最终的聚类结果。

### 实验和结果

- **数据集**：在多个公共数据集上进行测试，如MS-Celeb-1M、DeepFashion和MSMT17。
- **性能评估**：通过BCubed F-score和Pairwise F-score评估聚类性能。实验结果表明，Ada-NETS在所有测试中均达到最先进性能，显著提升了聚类精度。

![image-20240704112638427](C:\Users\DG2024\AppData\Roaming\Typora\typora-user-images\image-20240704112638427.png)